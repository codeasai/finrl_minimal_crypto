import streamlit as st
import os
import sys
from pathlib import Path
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime, timedelta
import numpy as np
import torch
from stable_baselines3 import PPO
from finrl.meta.env_stock_trading.env_stocktrading import StockTradingEnv
from finrl.agents.stablebaselines3.models import DRLAgent

# Add project root to Python path
root_path = Path(__file__).parent.parent.parent
sys.path.append(str(root_path))

from config import MODEL_DIR, INITIAL_AMOUNT, CRYPTO_SYMBOLS, DATA_DIR, TRANSACTION_COST_PCT, HMAX
from ui.pipeline.train import add_technical_indicators, prepare_data_for_training

def load_model_list():
    """Load list of available models"""
    if not os.path.exists(MODEL_DIR):
        return []
    
    models = []
    for f in os.listdir(MODEL_DIR):
        if f.endswith('.zip'):
            # Remove .zip extension and add to list
            model_name = f.replace('.zip', '')
            models.append(model_name)
    
    return models

def load_model(model_name):
    """Load a trained model"""
    try:
        # Add .zip extension if not present
        if not model_name.endswith('.zip'):
            model_name = f"{model_name}.zip"
            
        model_path = os.path.join(MODEL_DIR, model_name)
        if not os.path.exists(model_path):
            st.error(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà {model_path}")
            return None
            
        # ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏î‡πâ‡∏ß‡∏¢ device ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model = PPO.load(model_path, device=device)
        
        return model
    except Exception as e:
        st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•: {str(e)}")
        return None

def create_evaluation_env(df, initial_amount=INITIAL_AMOUNT):
    """‡∏™‡∏£‡πâ‡∏≤‡∏á environment ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô"""
    try:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if df is None or len(df) == 0:
            st.error("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á environment")
            return None
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
        elif 'timestamp' in df.columns:
            df['date'] = pd.to_datetime(df['timestamp'])
        else:
            st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå date ‡∏´‡∏£‡∏∑‡∏≠ timestamp ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
            return None
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå symbol
        if 'symbol' in df.columns:
            df['tic'] = df['symbol']
        elif 'tic' not in df.columns:
            st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå symbol ‡∏´‡∏£‡∏∑‡∏≠ tic ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
            return None
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏•‡∏∞ volume
        price_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in price_cols:
            if col not in df.columns:
                st.error(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå {col} ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
                return None
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô float
            df[col] = pd.to_numeric(df[col], errors='coerce')
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ NaN
        if df[price_cols].isna().any().any():
            st.warning("‡∏û‡∏ö‡∏Ñ‡πà‡∏≤ NaN ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤ ‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢")
            df[price_cols] = df[price_cols].fillna(df[price_cols].mean())
            
        # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î indicators ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
        indicators = [
            'sma_20', 'ema_20', 'rsi_14', 
            'macd', 'macd_signal', 'macd_hist',
            'bb_middle', 'bb_std', 'bb_upper', 'bb_lower',
            'volume_sma_20', 'volume_ratio'
        ]
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ indicators ‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        missing_indicators = [ind for ind in indicators if ind not in df.columns]
        if missing_indicators:
            st.warning(f"‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì indicators ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢: {', '.join(missing_indicators)}")
            df = add_technical_indicators(df)
            
        # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞ tic
        df = df.sort_values(['date', 'tic']).reset_index(drop=True)
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á environment
        env_kwargs = {
            "hmax": HMAX,
            "initial_amount": initial_amount,
            "num_stock_shares": [0] * len(df['tic'].unique()),
            "buy_cost_pct": [TRANSACTION_COST_PCT] * len(df['tic'].unique()),
            "sell_cost_pct": [TRANSACTION_COST_PCT] * len(df['tic'].unique()),
            "state_space": 1 + 2 * len(df['tic'].unique()) + len(df['tic'].unique()) * len(indicators),
            "stock_dim": len(df['tic'].unique()),
            "tech_indicator_list": indicators,
            "action_space": len(df['tic'].unique()),
            "reward_scaling": 1e-3,
            "print_verbosity": 1
        }
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á environment
        st.info(f"""
        üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô:
        - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: {len(df):,} ‡πÅ‡∏ñ‡∏ß
        - ‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô: {', '.join(df['tic'].unique())}
        - ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤: {df['date'].min()} ‡∏ñ‡∏∂‡∏á {df['date'].max()}
        - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô indicators: {len(indicators)}
        """)
        
        return StockTradingEnv(df=df, **env_kwargs)
        
    except Exception as e:
        st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á environment: {str(e)}")
        st.error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á")
        return None

def get_model_versions(model_name):
    """‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•"""
    try:
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô
        existing_files = [f for f in os.listdir(MODEL_DIR) 
                         if f.startswith(f"{model_name}_v") and f.endswith('.zip')]
        
        # ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö version files ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏ó‡∏ô
        if not existing_files:
            main_file = f"{model_name}.zip"
            if os.path.exists(os.path.join(MODEL_DIR, main_file)):
                return [{
                    'version': 1,
                    'file': main_file,
                    'path': os.path.join(MODEL_DIR, main_file),
                    'modified': datetime.fromtimestamp(os.path.getmtime(os.path.join(MODEL_DIR, main_file)))
                }]
            return []
        
        # ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡∏Ç‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö
        versions = []
        for file in existing_files:
            try:
                version = int(file.split('_v')[1].split('.')[0])
                versions.append({
                    'version': version,
                    'file': file,
                    'path': os.path.join(MODEL_DIR, file),
                    'modified': datetime.fromtimestamp(os.path.getmtime(os.path.join(MODEL_DIR, file)))
                })
            except:
                continue
        
        return sorted(versions, key=lambda x: x['version'])
    except:
        return []

def plot_version_comparison(version_results):
    """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô"""
    fig = go.Figure()
    
    # ‡∏™‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô
    colors = ['#2E8B57', '#4169E1', '#DC143C', '#FF8C00', '#9932CC', '#20B2AA']
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô
    for i, (version, result) in enumerate(version_results.items()):
        fig.add_trace(go.Scatter(
            x=result['dates'],
            y=result['account_values'],
            name=f"Version {version}",
            line=dict(color=colors[i % len(colors)], width=2)
        ))
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô benchmark
    fig.add_trace(go.Scatter(
        x=version_results[list(version_results.keys())[0]]['dates'],
        y=version_results[list(version_results.keys())[0]]['benchmark_values'],
        name="Buy & Hold",
        line=dict(color="#808080", width=2, dash="dash")
    ))
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    fig.add_trace(go.Scatter(
        x=version_results[list(version_results.keys())[0]]['dates'],
        y=[INITIAL_AMOUNT] * len(version_results[list(version_results.keys())[0]]['dates']),
        name="Initial Investment",
        line=dict(color="#000000", width=1, dash="dot")
    ))
    
    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó layout
    fig.update_layout(
        title="Version Comparison",
        xaxis_title="Date",
        yaxis_title="Portfolio Value ($)",
        hovermode="x unified",
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01
        )
    )
    
    return fig

def calculate_metrics(account_values, benchmark_values, initial_amount):
    """Calculate performance metrics"""
    try:
        # Calculate returns
        total_return = (account_values[-1] - initial_amount) / initial_amount * 100
        benchmark_return = (benchmark_values[-1] - initial_amount) / initial_amount * 100
        
        # Calculate daily returns
        daily_returns = pd.Series(account_values).pct_change().dropna()
        benchmark_daily_returns = pd.Series(benchmark_values).pct_change().dropna()
        
        # Calculate metrics
        sharpe_ratio = daily_returns.mean() / daily_returns.std() * (252 ** 0.5)  # Annualized
        max_drawdown = ((pd.Series(account_values).cummax() - account_values) / 
                       pd.Series(account_values).cummax()).max() * 100
        
        return {
            "Total Return (%)": f"{total_return:.2f}%",
            "vs. Buy & Hold": f"{total_return - benchmark_return:+.2f}%",
            "Sharpe Ratio": f"{sharpe_ratio:.2f}",
            "Max Drawdown (%)": f"{max_drawdown:.2f}%",
            "Final Portfolio Value": f"${account_values[-1]:,.2f}"
        }
    except Exception as e:
        st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì metrics: {str(e)}")
        return None

def evaluate_agent_ui():
    """UI for evaluating agent performance"""
    st.header("üìà Evaluate Agent Performance")
    
    # Load available models
    models = load_model_list()
    if not models:
        st.info("No trained models found. Please train a model first!")
        return
    
    # Model selection
    model_name = st.selectbox(
        "Select Model to Evaluate",
        models,
        help="Choose a trained model to evaluate its performance"
    )
    
    # ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•
    versions = get_model_versions(model_name)
    if not versions:
        st.warning("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏µ‡πâ")
        return
    
    # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö
    st.subheader("üìä Version Comparison")
    selected_versions = st.multiselect(
        "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö",
        options=[v['version'] for v in versions],
        default=[v['version'] for v in versions[-2:]],  # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 2 ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        help="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û"
    )
    
    if not selected_versions:
        st.warning("‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö")
        return
    
    # Data file selection
    data_files = [f for f in os.listdir(DATA_DIR) if f.endswith('.csv')] if os.path.exists(DATA_DIR) else []
    if not data_files:
        st.warning("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå data ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô")
        return

    selected_data_file = st.selectbox(
        "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô",
        data_files,
        help="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô"
    )
    
    # Date range selection
    col1, col2 = st.columns(2)
    with col1:
        start_date = st.date_input(
            "Start Date",
            datetime.now() - timedelta(days=30),
            help="Start date for evaluation period"
        )
    with col2:
        end_date = st.date_input(
            "End Date",
            datetime.now(),
            help="End date for evaluation period"
        )
    
    # Trading parameters
    with st.expander("üîß Trading Parameters"):
        initial_amount = st.number_input(
            "Initial Investment ($)",
            min_value=1000,
            value=INITIAL_AMOUNT,
            step=1000,
            help="Starting portfolio value"
        )
    
    if st.button("üìä Run Evaluation"):
        with st.spinner("Running evaluation..."):
            try:
                # ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                file_path = os.path.join(DATA_DIR, selected_data_file)
                if not os.path.exists(file_path):
                    st.error(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà {file_path}")
                    return
                    
                df = pd.read_csv(file_path)
                
                # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                processed_df = prepare_data_for_training(df)
                
                # ‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
                processed_df['date'] = pd.to_datetime(processed_df['date'])
                mask = (processed_df['date'].dt.date >= start_date) & (processed_df['date'].dt.date <= end_date)
                eval_df = processed_df[mask].copy()
                
                if len(eval_df) == 0:
                    st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å")
                    return
                
                # ‡∏™‡∏£‡πâ‡∏≤‡∏á environment
                env = create_evaluation_env(eval_df, initial_amount)
                if env is None:
                    return
                
                # ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô
                version_results = {}
                
                # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô
                for version in selected_versions:
                    version_info = next(v for v in versions if v['version'] == version)
                    
                    # ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•
                    model = load_model(version_info['file'].replace(".zip", ""))
                    if model is None:
                        continue
                    
                    # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•
                    try:
                        df_account_value, df_actions = DRLAgent.DRL_prediction(
                            model=model,
                            environment=env
                        )
                        
                        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì benchmark (Buy & Hold)
                        benchmark_values = []
                        for date in eval_df['date'].unique():
                            date_data = eval_df[eval_df['date'] == date]
                            benchmark_value = initial_amount * (date_data['close'].iloc[0] / eval_df['close'].iloc[0])
                            benchmark_values.append(benchmark_value)
                        
                        # ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                        version_results[version] = {
                            'dates': eval_df['date'].unique(),
                            'account_values': df_account_value['account_value'].values,
                            'benchmark_values': benchmark_values,
                            'metrics': calculate_metrics(
                                df_account_value['account_value'].values,
                                benchmark_values,
                                initial_amount
                            )
                        }
                        
                    except Exception as e:
                        st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô {version}: {str(e)}")
                        continue
                
                if not version_results:
                    st.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏ú‡∏•‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å")
                    return
                
                # ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö
                st.plotly_chart(plot_version_comparison(version_results))
                
                # ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö metrics
                st.subheader("üìä Performance Comparison")
                metrics_df = pd.DataFrame({
                    'Version': [],
                    'Total Return (%)': [],
                    'vs. Buy & Hold': [],
                    'Sharpe Ratio': [],
                    'Max Drawdown (%)': [],
                    'Final Portfolio Value': []
                })
                
                for version, result in version_results.items():
                    metrics = result['metrics']
                    metrics_df = pd.concat([metrics_df, pd.DataFrame({
                        'Version': [f"v{version}"],
                        'Total Return (%)': [metrics['Total Return (%)']],
                        'vs. Buy & Hold': [metrics['vs. Buy & Hold']],
                        'Sharpe Ratio': [metrics['Sharpe Ratio']],
                        'Max Drawdown (%)': [metrics['Max Drawdown (%)']],
                        'Final Portfolio Value': [metrics['Final Portfolio Value']]
                    })])
                
                st.dataframe(metrics_df, hide_index=True)
                
                # Download results button
                results_df = pd.DataFrame()
                for version, result in version_results.items():
                    version_df = pd.DataFrame({
                        'Date': result['dates'],
                        f'Portfolio_Value_v{version}': result['account_values'],
                        'Benchmark_Value': result['benchmark_values']
                    })
                    if results_df.empty:
                        results_df = version_df
                    else:
                        results_df = results_df.merge(version_df, on='Date', how='outer')
                
                st.download_button(
                    "üì• Download Comparison Report",
                    results_df.to_csv(index=False),
                    "version_comparison_report.csv",
                    help="Download detailed comparison results as CSV"
                )
                
            except Exception as e:
                st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô: {str(e)}")
                st.error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á") 